name: validate
on:
  pull_request:
  push:
    branches: [ main ]

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Install yq (for YAML processing)
      - name: Install yq
        run: |
          set -euo pipefail
          YQ_VERSION=v4.44.3
          curl -L "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64" -o /usr/local/bin/yq
          chmod +x /usr/local/bin/yq
          yq --version

      # Collect & sanitize manifests:
      #  - exclude .git/ and build/
      #  - keep only K8s docs (has apiVersion + kind)
      #  - drop the .sops block
      #  - SKIP Secrets entirely (avoids SOPS-induced schema noise)
# Replace the "Collect & sanitize manifests" step with this
      - name: Collect & sanitize manifests (skip SOPS files)
        run: |
          set -euo pipefail
          mkdir -p build

          # Collect all YAML paths (excluding .git/, build/, decrypted/)
          mapfile -d '' all < <(find . -type f \( -name '*.yaml' -o -name '*.yml' \) \
                                  -not -path './.git/*' -not -path './build/*' -not -path './decrypted/*' -print0)

          # Split into encrypted vs plain using yq: a file is "encrypted" if it has a top-level 'sops' key
          encrypted=()
          plain=()
          for f in "${all[@]}"; do
            if yq 'has("sops")' "$f" | grep -q true; then
              encrypted+=("$f")
            else
              plain+=("$f")
            fi
          done

          # Log what we're skipping
          echo "SOPS-encrypted files skipped by CI validation:"
          printf '  - %s\n' "${encrypted[@]:-<none>}"

          # Build sanitized bundle from only *plain* files
          if [ ${#plain[@]} -eq 0 ]; then
            echo "No non-encrypted Kubernetes YAMLs found to validate."
            # If you prefer not to fail when everything is encrypted, uncomment the next line:
            # exit 0
            exit 1
          fi

          yq ea '
            select(type == "!!map") |
            select(has("apiVersion") and has("kind")) |
            del(.sops)
          ' "${plain[@]}" > build/manifests.sanitized.yaml

          test -s build/manifests.sanitized.yaml || { echo "No Kubernetes manifests found after sanitation."; exit 1; }

          echo "Sanitized manifest line count:"
          wc -l build/manifests.sanitized.yaml


      # kubeconform: fast schema validation (supports CRDs)
      - name: Setup kubeconform
        uses: bmuschko/setup-kubeconform@v1

      - name: Run kubeconform
        run: |
          set -euo pipefail
          kubeconform \
            -strict \
            -ignore-missing-schemas \
            -summary \
            -output json \
            build/manifests.sanitized.yaml

      # Kubesec: risk analysis + upload to Security tab
      - name: Kubesec scan
        uses: controlplaneio/kubesec-action@43d0ddff5ffee89a6bb9f29b64cd865411137b14
        with:
          input: build/manifests.sanitized.yaml
          format: template
          template: template/sarif.tpl
          output: kubesec-results.sarif
          exit-code: "0"

      - name: Upload SARIF
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: kubesec-results.sarif
