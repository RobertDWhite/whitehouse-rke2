name: validate
on:
  pull_request:
  push:
    branches: [ main ]

permissions:
  contents: read
  actions: read
  security-events: write

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Install yq (for YAML processing)
      - name: Install yq
        run: |
          set -euo pipefail
          YQ_VERSION=v4.44.3
          curl -L "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64" -o /usr/local/bin/yq
          chmod +x /usr/local/bin/yq
          yq --version

      # Collect & sanitize manifests (skip SOPS-encrypted docs and Secrets)
      - name: Collect & sanitize manifests (skip SOPS-encrypted docs)
        run: |
          set -euo pipefail
          mkdir -p build
          mapfile -d '' files < <(find . -type f \( -name '*.yaml' -o -name '*.yml' \) \
                                    -not -path './.git/*' -not -path './build/*' -print0)
          if [ ${#files[@]} -eq 0 ]; then
            echo "No YAMLs found"; exit 1
          fi

          echo "SOPS-encrypted files being skipped:"
          for f in "${files[@]}"; do
            if yq 'has("sops")' "$f" | grep -q true; then
              echo "  - $f"
            fi
          done

          yq ea '
            select(type == "!!map") |
            select(has("apiVersion") and has("kind")) |
            select(has("sops") | not) |
            select(.kind != "Secret")
          ' "${files[@]}" > build/manifests.sanitized.yaml

          test -s build/manifests.sanitized.yaml || { echo "No Kubernetes manifests found after sanitation."; exit 1; }
          echo "Sanitized manifest line count:"; wc -l build/manifests.sanitized.yaml

      # kubeconform: schema validation
      - name: Setup kubeconform
        uses: bmuschko/setup-kubeconform@v1

      - name: Run kubeconform
        run: |
          set -euo pipefail
          kubeconform \
            -strict \
            -ignore-missing-schemas \
            -summary \
            -output json \
            build/manifests.sanitized.yaml

      # Kubesec: risk analysis + SARIF (use built-in template path)
      - name: Kubesec scan
        uses: controlplaneio/kubesec-action@43d0ddff5ffee89a6bb9f29b64cd865411137b14
        with:
          input: build/manifests.sanitized.yaml
          format: template
          template: /templates/sarif.tpl
          output: kubesec-results.sarif
          exit-code: "0"

      # Normalize SARIF to a single run (robust) â€” never fail this step; fall back if needed
      - name: Normalize SARIF to single run
        run: |
          set -euo pipefail
          command -v jq >/dev/null 2>&1 || (sudo apt-get update && sudo apt-get install -y jq)

          # If file is empty, bail out early
          if [ ! -s kubesec-results.sarif ]; then
            echo "kubesec-results.sarif is empty"; exit 1
          fi

          # Try robust normalization; on any jq failure, fall back to original file
          if jq '
              def base:
                {
                  "$schema": (."$schema" // "https://json.schemastore.org/sarif-2.1.0.json"),
                  "version": (.version   // "2.1.0")
                };

              def flatten_to_single_run:
                ( .runs // [] ) as $r
                | if ($r | length) <= 1 then
                    . # already single (or zero) run
                  else
                    base + {
                      runs: [
                        ( $r[0]
                          | .results     = ([ $r[] | (.results     // []) ] | add)
                          | .artifacts   = ([ $r[] | (.artifacts   // []) ] | add)
                          | .invocations = ([ $r[] | (.invocations // []) ] | add)
                        )
                      ]
                    }
                  end;

              if (type == "object") then
                flatten_to_single_run
              else
                # If not an object (unlikely), wrap into a minimal SARIF shell
                base + { runs: [] }
              end
            ' kubesec-results.sarif > kubesec-results.single.sarif
          then
            echo "Normalization succeeded."
          else
            echo "Normalization failed; using original SARIF."
            cp kubesec-results.sarif kubesec-results.single.sarif
          fi

          # Print resulting run count (non-fatal)
          ( jq '.runs | length' kubesec-results.single.sarif 2>/dev/null || echo "unknown" ) | xargs echo "Runs after normalize:"

      # Upload SARIF (skip if forked PR)
      - name: Upload SARIF
        if: ${{ github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository }}
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: kubesec-results.single.sarif
          category: kubesec
