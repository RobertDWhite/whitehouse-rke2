apiVersion: v1
kind: ConfigMap
metadata:
  name: channelizer-scripts
  namespace: sdr-research
data:
  channelize.py: |
    #!/usr/bin/env python3
    import os, json, time
    import numpy as np
    from gnuradio import gr, blocks
    import osmosdr
    from scipy.signal import find_peaks

    SAMPLE_RATE = 2_400_000
    FFT_SIZE = 4096
    ENERGY_THRESHOLD_DB = -50
    CAPTURE_SECONDS = 1

    OUT_DIR = "/data/detections"
    os.makedirs(OUT_DIR, exist_ok=True)

    # VHF/UHF HAM BANDS (Hz)
    HAM_BANDS = {
        "2m":  (144_000_000, 148_000_000),
        "70cm": (420_000_000, 450_000_000),
    }

    STEP_HZ = SAMPLE_RATE // 2   # overlap for safety

    class Channelizer(gr.top_block):
        def __init__(self):
            gr.top_block.__init__(self, "VHF/UHF Ham Channelizer")

            self.src = osmosdr.source(
                args="rtl_tcp=rtl-tcp.sdr-research.svc.cluster.local:1234"
            )
            self.src.set_sample_rate(SAMPLE_RATE)
            self.src.set_gain_mode(True)

            self.head = blocks.head(
                gr.sizeof_gr_complex,
                int(SAMPLE_RATE * CAPTURE_SECONDS)
            )
            self.sink = blocks.vector_sink_c()

            self.connect(self.src, self.head, self.sink)

        def capture_fft(self, center_freq):
            self.src.set_center_freq(center_freq)
            time.sleep(0.1)  # allow PLL settle

            self.sink.reset()
            self.run()

            iq = np.array(self.sink.data())
            fft = np.fft.fftshift(np.fft.fft(iq, FFT_SIZE))
            power = 20 * np.log10(np.abs(fft) + 1e-12)

            freqs = np.fft.fftshift(
                np.fft.fftfreq(FFT_SIZE, d=1/SAMPLE_RATE)
            ) + center_freq

            return freqs, power

    if __name__ == "__main__":
        ch = Channelizer()
        detections = []

        for band, (f_start, f_end) in HAM_BANDS.items():
            freq = f_start
            while freq < f_end:
                freqs, power = ch.capture_fft(freq)

                peaks, props = find_peaks(power, height=ENERGY_THRESHOLD_DB)
                for p in peaks:
                    detections.append({
                        "band": band,
                        "frequency_hz": float(freqs[p]),
                        "power_db": float(power[p])
                    })

                freq += STEP_HZ

        out = {
            "source": "rtl_tcp",
            "sample_rate": SAMPLE_RATE,
            "detections": detections
        }

        path = os.path.join(OUT_DIR, "detections.json")
        with open(path, "w") as f:
            json.dump(out, f, indent=2)

        print(f"Wrote {path} ({len(detections)} detections)")
